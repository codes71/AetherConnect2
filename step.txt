# AetherConnect Development Plan: 10 Phases for 1-Month Timeline

Based on our comprehensive analysis of the AetherConnect project, here's a structured 10-phase development plan that will get you from foundation to production-ready system within 30 days.[1][2]

## Phase Overview (1-Month Timeline)

Phase	Days	Core Focus	What You'll See Working
Phase 1	1-3	Single service + DB working	Auth service responding via HTTP
Phase 2	4-6	JWT auth + user management	Login/register working
Phase 3	7-9	API Gateway + gRPC microservices	NestJS API Gateway and Auth microservice communicating via gRPC
Phase 4	10-12	WebSocket Messaging Service with real-time chat	Live real-time messaging in chat app terminal and frontend
Phase 5	13-15	Frontend integration with Next.js and backend services	Fully functional frontend connected to backend via REST and WebSocket
Phase 6	16-18	Multi-room + file upload	Chat rooms + file sharing
Phase 7	19-21	Kafka events + notifications	Event-driven architecture
Phase 8	22-24	AI moderation + Redis caching	Content filtering working
Phase 9	25-27	Observability (metrics/logs)	Monitoring dashboards
Phase 10	28-30	Production deployment	Kubernetes + CI/CD

# üöÄ Phase 3: NestJS + gRPC Microservices Transition (Days 7-9)

**LET'S GO!** Time for the **real architectural transformation**! We're converting your Express service into enterprise-grade NestJS microservices with gRPC communication.

***

# Day 7: Project Restructure & Protobuf Setup

## Step 1: Create New Project Structure

```bash
# Navigate to your project root
cd aetherconnect

# Create new structure for microservices
mkdir -p packages/shared/src/{grpc,dtos,types,constants,utils}
mkdir -p packages/protos
mkdir -p services/auth-service-nestjs/src/{auth,users,database,common}
mkdir -p services/api-gateway/src/{auth,common,middleware}

# Keep your old Express service for reference
mv services/auth-service services/auth-service-express-backup
```

**What this does**: Sets up proper microservices structure with shared libraries and proto definitions.

## Step 2: Protocol Buffer Definitions

### **packages/protos/auth.proto**
```protobuf
syntax = "proto3";

package auth;

service AuthService {
  rpc CreateUser(CreateUserRequest) returns (UserResponse);
  rpc ValidateToken(ValidateTokenRequest) returns (ValidateTokenResponse);
  rpc Login(LoginRequest) returns (AuthResponse);
  rpc RefreshToken(RefreshTokenRequest) returns (AuthResponse);
  rpc GetUserProfile(GetUserProfileRequest) returns (UserResponse);
  rpc UpdateUserProfile(UpdateUserProfileRequest) returns (UserResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message CreateUserRequest {
  string username = 1;
  string email = 2;
  string password = 3;
  string firstName = 4;
  string lastName = 5;
  repeated string roles = 6;
}

message LoginRequest {
  string email = 1;
  string password = 2;
}

message ValidateTokenRequest {
  string token = 1;
}

message RefreshTokenRequest {
  string refreshToken = 1;
}

message GetUserProfileRequest {
  string userId = 1;
}

message UpdateUserProfileRequest {
  string userId = 1;
  optional string firstName = 2;
  optional string lastName = 3;
  optional string username = 4;
}

message HealthCheckRequest {}

message UserResponse {
  bool success = 1;
  string message = 2;
  optional UserData user = 3;
  optional string error = 4;
}

message ValidateTokenResponse {
  bool success = 1;
  string message = 2;
  optional UserData user = 3;
  bool isValid = 4;
  optional string error = 5;
}

message AuthResponse {
  bool success = 1;
  string message = 2;
  optional UserData user = 3;
  optional string accessToken = 4;
  optional string refreshToken = 5;
  optional string error = 6;
}

message HealthCheckResponse {
  bool success = 1;
  string message = 2;
  string service = 3;
  string version = 4;
  string timestamp = 5;
}

message UserData {
  string id = 1;
  string username = 2;
  string email = 3;
  string firstName = 4;
  string lastName = 5;
  repeated string roles = 6;
  string createdAt = 7;
  string updatedAt = 8;
}
```

### **packages/protos/common.proto**
```protobuf
syntax = "proto3";

package common;

message Empty {}

message Error {
  string code = 1;
  string message = 2;
  repeated string details = 3;
}

message PaginationRequest {
  int32 page = 1;
  int32 limit = 2;
  string sortBy = 3;
  string sortOrder = 4;
}

message PaginationResponse {
  int32 currentPage = 1;
  int32 totalPages = 2;
  int32 totalItems = 3;
  int32 itemsPerPage = 4;
  bool hasNext = 5;
  bool hasPrevious = 6;
}
```

## Step 3: Enhanced Shared Package

### **packages/shared/package.json**
```json
{
  "name": "@aether/shared",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist"],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "clean": "rm -rf dist",
    "test": "jest",
    "lint": "eslint src/**/*.ts --fix"
  },
  "dependencies": {
    "@grpc/grpc-js": "^1.9.7",
    "@grpc/proto-loader": "^0.7.10",
    "zod": "^3.22.4",
    "winston": "^3.11.0",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "typescript": "^5.2.2",
    "@types/node": "^20.8.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.5",
    "eslint": "^8.50.0",
    "@typescript-eslint/eslint-plugin": "^6.7.0",
    "@typescript-eslint/parser": "^6.7.0"
  }
}
```

### **packages/shared/src/grpc/auth-client.ts**
```typescript
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import { join } from 'path';
import { logger } from '../utils/logger';

const PROTO_PATH = join(__dirname, '../../../protos/auth.proto');

export interface AuthServiceClient {
  CreateUser(request: any): Promise<any>;
  ValidateToken(request: any): Promise<any>;
  Login(request: any): Promise<any>;
  RefreshToken(request: any): Promise<any>;
  GetUserProfile(request: any): Promise<any>;
  UpdateUserProfile(request: any): Promise<any>;
  HealthCheck(request: any): Promise<any>;
}

export class AuthGrpcClient implements AuthServiceClient {
  private client: any;
  private readonly serviceName = 'AuthService';

  constructor(address: string = 'localhost:50001') {
    try {
      const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
      });

      const authProto = grpc.loadPackageDefinition(packageDefinition) as any;
      
      this.client = new authProto.auth.AuthService(
        address,
        grpc.credentials.createInsecure(),
        {
          'grpc.keepalive_time_ms': 30000,
          'grpc.keepalive_timeout_ms': 5000,
          'grpc.keepalive_permit_without_calls': true,
          'grpc.http2.max_pings_without_data': 0,
          'grpc.http2.min_time_between_pings_ms': 10000,
          'grpc.http2.min_ping_interval_without_data_ms': 300000,
        }
      );

      logger.info(`gRPC client connected to ${this.serviceName} at ${address}`);
    } catch (error) {
      logger.error(`Failed to initialize gRPC client for ${this.serviceName}:`, error);
      throw error;
    }
  }

  private promisifyCall(method: string, request: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.client[method](request, (error: any, response: any) => {
        if (error) {
          logger.error(`gRPC ${method} error:`, error);
          reject(error);
        } else {
          logger.debug(`gRPC ${method} success:`, { request, response });
          resolve(response);
        }
      });
    });
  }

  async CreateUser(request: any): Promise<any> {
    return this.promisifyCall('CreateUser', request);
  }

  async ValidateToken(request: any): Promise<any> {
    return this.promisifyCall('ValidateToken', request);
  }

  async Login(request: any): Promise<any> {
    return this.promisifyCall('Login', request);
  }

  async RefreshToken(request: any): Promise<any> {
    return this.promisifyCall('RefreshToken', request);
  }

  async GetUserProfile(request: any): Promise<any> {
    return this.promisifyCall('GetUserProfile', request);
  }

  async UpdateUserProfile(request: any): Promise<any> {
    return this.promisifyCall('UpdateUserProfile', request);
  }

  async HealthCheck(request: any = {}): Promise<any> {
    return this.promisifyCall('HealthCheck', request);
  }
}
```

### **packages/shared/src/utils/logger.ts**
```typescript
import winston from 'winston';

const logLevel = process.env.LOG_LEVEL || 'info';
const nodeEnv = process.env.NODE_ENV || 'development';

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.json(),
  winston.format.printf(({ level, message, timestamp, stack, service, requestId, userId, ...meta }) => {
    const logObject = {
      timestamp,
      level: level.toUpperCase(),
      service: service || 'unknown',
      message,
      ...(requestId && { requestId }),
      ...(userId && { userId }),
      ...(Object.keys(meta).length > 0 && { meta }),
      ...(stack && { stack }),
    };
    return JSON.stringify(logObject);
  })
);

export const logger = winston.createLogger({
  level: logLevel,
  format: logFormat,
  defaultMeta: { service: 'aetherconnect' },
  transports: [
    new winston.transports.Console({
      format: nodeEnv === 'development' 
        ? winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        : logFormat
    }),
  ],
});

export const createServiceLogger = (serviceName: string) => {
  return logger.child({ service: serviceName });
};
```

### **packages/shared/src/index.ts**
```typescript
// gRPC clients
export * from './grpc/auth-client';

// DTOs and types
export * from './dtos/user.dto';
export * from './types/common.types';

// Utilities
export * from './utils/logger';

// Constants
export * from './constants/errors';
```

***

# Day 8: NestJS Auth Service Implementation

## Step 4: NestJS Auth Service Setup

### **services/auth-service-nestjs/package.json**
```json
{
  "name": "@aether/auth-service-nestjs",
  "version": "1.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "nest build",
    "dev": "nest start --watch",
    "start": "node dist/main",
    "start:debug": "nest start --debug --watch",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "@nestjs/common": "^10.2.7",
    "@nestjs/core": "^10.2.7",
    "@nestjs/microservices": "^10.2.7",
    "@nestjs/typeorm": "^10.0.0",
    "@nestjs/jwt": "^10.1.1",
    "@nestjs/config": "^3.1.1",
    "typeorm": "^0.3.17",
    "pg": "^8.11.3",
    "bcryptjs": "^2.4.3",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "@grpc/grpc-js": "^1.9.7",
    "@grpc/proto-loader": "^0.7.10",
    "@aether/shared": "workspace:*",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.1.18",
    "@nestjs/schematics": "^10.0.2",
    "@nestjs/testing": "^10.2.7",
    "typescript": "^5.2.2",
    "@types/node": "^20.8.0",
    "@types/bcryptjs": "^2.4.4",
    "@types/uuid": "^9.0.5",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.5",
    "ts-jest": "^29.1.1",
    "eslint": "^8.50.0",
    "source-map-support": "^0.5.21"
  }
}
```

### **services/auth-service-nestjs/nest-cli.json**
```json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
```

### **services/auth-service-nestjs/src/main.ts**
```typescript
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { join } from 'path';
import { AppModule } from './app.module';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('auth-service');

async function bootstrap() {
  try {
    const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
      transport: Transport.GRPC,
      options: {
        package: 'auth',
        protoPath: join(__dirname, '../../../packages/protos/auth.proto'),
        url: `0.0.0.0:${process.env.AUTH_SERVICE_GRPC_PORT || 50001}`,
        loader: {
          keepCase: true,
          longs: String,
          enums: String,
          defaults: true,
          oneofs: true,
        },
      },
    });

    await app.listen();
    
    const port = process.env.AUTH_SERVICE_GRPC_PORT || 50001;
    logger.info(`üîê Auth Service (gRPC) is listening on port ${port}`);
    logger.info(`üìã Proto path: ${join(__dirname, '../../../packages/protos/auth.proto')}`);
    
    // Graceful shutdown
    process.on('SIGTERM', async () => {
      logger.info('SIGTERM received, shutting down gracefully');
      await app.close();
      process.exit(0);
    });

  } catch (error) {
    logger.error('Failed to start Auth Service:', error);
    process.exit(1);
  }
}

bootstrap();
```

### **services/auth-service-nestjs/src/app.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { JwtModule } from '@nestjs/jwt';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '../../../.env',
    }),
    DatabaseModule,
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET || 'your-secret-key',
      signOptions: { expiresIn: '15m' },
    }),
    AuthModule,
    UsersModule,
  ],
})
export class AppModule {}
```

### **services/auth-service-nestjs/src/database/database.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from '../users/entities/user.entity';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      url: process.env.POSTGRES_URL || 'postgresql://aether:secret123@localhost:5432/aetherconnect',
      entities: [User],
      synchronize: process.env.NODE_ENV !== 'production', // Only for development!
      logging: process.env.NODE_ENV === 'development',
      ssl: false,
    }),
  ],
})
export class DatabaseModule {}
```

### **services/auth-service-nestjs/src/users/entities/user.entity.ts**
```typescript
import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ unique: true, length: 50 })
  username: string;

  @Column({ unique: true, length: 255 })
  email: string;

  @Column({ name: 'password_hash', length: 255 })
  passwordHash: string;

  @Column({ name: 'first_name', length: 50 })
  firstName: string;

  @Column({ name: 'last_name', length: 50 })
  lastName: string;

  @Column('simple-array', { default: 'user' })
  roles: string[];

  @Column({ name: 'refresh_token_hash', length: 255, nullable: true })
  refreshTokenHash: string;

  @Column({ name: 'refresh_token_expires_at', type: 'timestamp', nullable: true })
  refreshTokenExpiresAt: Date;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}
```

### **services/auth-service-nestjs/src/auth/auth.controller.ts**
```typescript
import { Controller } from '@nestjs/common';
import { GrpcMethod } from '@nestjs/microservices';
import { AuthService } from './auth.service';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('auth-controller');

@Controller()
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @GrpcMethod('AuthService', 'CreateUser')
  async createUser(data: any) {
    try {
      logger.info('CreateUser gRPC call received', { email: data.email, username: data.username });
      const result = await this.authService.createUser(data);
      logger.info('CreateUser completed successfully', { userId: result.user?.id });
      return result;
    } catch (error) {
      logger.error('CreateUser failed:', error);
      return {
        success: false,
        message: 'User creation failed',
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'Login')
  async login(data: any) {
    try {
      logger.info('Login gRPC call received', { email: data.email });
      const result = await this.authService.login(data);
      logger.info('Login completed', { success: result.success, userId: result.user?.id });
      return result;
    } catch (error) {
      logger.error('Login failed:', error);
      return {
        success: false,
        message: 'Login failed',
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'ValidateToken')
  async validateToken(data: any) {
    try {
      logger.debug('ValidateToken gRPC call received');
      const result = await this.authService.validateToken(data.token);
      logger.debug('ValidateToken completed', { isValid: result.isValid });
      return result;
    } catch (error) {
      logger.error('ValidateToken failed:', error);
      return {
        success: false,
        message: 'Token validation failed',
        isValid: false,
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'RefreshToken')
  async refreshToken(data: any) {
    try {
      logger.info('RefreshToken gRPC call received');
      const result = await this.authService.refreshToken(data.refreshToken);
      logger.info('RefreshToken completed', { success: result.success });
      return result;
    } catch (error) {
      logger.error('RefreshToken failed:', error);
      return {
        success: false,
        message: 'Token refresh failed',
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'GetUserProfile')
  async getUserProfile(data: any) {
    try {
      logger.info('GetUserProfile gRPC call received', { userId: data.userId });
      const result = await this.authService.getUserProfile(data.userId);
      logger.info('GetUserProfile completed', { success: result.success });
      return result;
    } catch (error) {
      logger.error('GetUserProfile failed:', error);
      return {
        success: false,
        message: 'Failed to get user profile',
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'UpdateUserProfile')
  async updateUserProfile(data: any) {
    try {
      logger.info('UpdateUserProfile gRPC call received', { userId: data.userId });
      const result = await this.authService.updateUserProfile(data);
      logger.info('UpdateUserProfile completed', { success: result.success });
      return result;
    } catch (error) {
      logger.error('UpdateUserProfile failed:', error);
      return {
        success: false,
        message: 'Failed to update user profile',
        error: error.message,
      };
    }
  }

  @GrpcMethod('AuthService', 'HealthCheck')
  async healthCheck() {
    return {
      success: true,
      message: 'Auth Service is healthy',
      service: 'auth-service',
      version: '1.0.0',
      timestamp: new Date().toISOString(),
    };
  }
}
```

### **services/auth-service-nestjs/src/auth/auth.service.ts**
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcryptjs';
import { User } from '../users/entities/user.entity';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('auth-service');

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly jwtService: JwtService,
  ) {}

  async createUser(data: any) {
    try {
      // Check if user already exists
      const existingUser = await this.userRepository.findOne({
        where: [{ email: data.email }, { username: data.username }],
      });

      if (existingUser) {
        return {
          success: false,
          message: 'User with this email or username already exists',
        };
      }

      // Hash password
      const passwordHash = await bcrypt.hash(data.password, 12);

      // Create user
      const user = this.userRepository.create({
        username: data.username,
        email: data.email,
        passwordHash,
        firstName: data.firstName,
        lastName: data.lastName,
        roles: data.roles || ['user'],
      });

      const savedUser = await this.userRepository.save(user);

      // Generate tokens
      const { accessToken, refreshToken } = await this.generateTokens(savedUser);

      // Save refresh token
      await this.saveRefreshToken(savedUser.id, refreshToken);

      return {
        success: true,
        message: 'User created successfully',
        user: this.formatUserData(savedUser),
        accessToken,
        refreshToken,
      };
    } catch (error) {
      logger.error('User creation failed:', error);
      throw error;
    }
  }

  async login(data: any) {
    try {
      const user = await this.userRepository.findOne({
        where: { email: data.email },
      });

      if (!user) {
        return {
          success: false,
          message: 'Invalid credentials',
        };
      }

      const isPasswordValid = await bcrypt.compare(data.password, user.passwordHash);
      if (!isPasswordValid) {
        return {
          success: false,
          message: 'Invalid credentials',
        };
      }

      // Generate tokens
      const { accessToken, refreshToken } = await this.generateTokens(user);

      // Save refresh token
      await this.saveRefreshToken(user.id, refreshToken);

      return {
        success: true,
        message: 'Login successful',
        user: this.formatUserData(user),
        accessToken,
        refreshToken,
      };
    } catch (error) {
      logger.error('Login failed:', error);
      throw error;
    }
  }

  async validateToken(token: string) {
    try {
      const decoded = this.jwtService.verify(token, {
        secret: process.env.JWT_SECRET || 'your-secret-key',
      });

      const user = await this.userRepository.findOne({
        where: { id: decoded.userId },
      });

      if (!user) {
        return {
          success: false,
          message: 'User not found',
          isValid: false,
        };
      }

      return {
        success: true,
        message: 'Token is valid',
        isValid: true,
        user: this.formatUserData(user),
      };
    } catch (error) {
      return {
        success: false,
        message: 'Invalid token',
        isValid: false,
      };
    }
  }

  async refreshToken(refreshToken: string) {
    try {
      const decoded = this.jwtService.verify(refreshToken, {
        secret: process.env.JWT_REFRESH_SECRET || 'your-refresh-secret',
      });

      const user = await this.userRepository.findOne({
        where: { 
          id: decoded.userId,
        },
      });

      if (!user || !user.refreshTokenHash || user.refreshTokenExpiresAt < new Date()) {
        return {
          success: false,
          message: 'Invalid refresh token',
        };
      }

      const isValidRefresh = await bcrypt.compare(refreshToken, user.refreshTokenHash);
      if (!isValidRefresh) {
        return {
          success: false,
          message: 'Invalid refresh token',
        };
      }

      // Generate new access token
      const accessToken = this.jwtService.sign(
        { userId: user.id, email: user.email },
        { 
          secret: process.env.JWT_SECRET || 'your-secret-key',
          expiresIn: '15m' 
        }
      );

      return {
        success: true,
        message: 'Token refreshed successfully',
        accessToken,
      };
    } catch (error) {
      return {
        success: false,
        message: 'Token refresh failed',
      };
    }
  }

  async getUserProfile(userId: string) {
    try {
      const user = await this.userRepository.findOne({
        where: { id: parseInt(userId) },
      });

      if (!user) {
        return {
          success: false,
          message: 'User not found',
        };
      }

      return {
        success: true,
        message: 'User profile retrieved successfully',
        user: this.formatUserData(user),
      };
    } catch (error) {
      logger.error('Get user profile failed:', error);
      throw error;
    }
  }

  async updateUserProfile(data: any) {
    try {
      const user = await this.userRepository.findOne({
        where: { id: parseInt(data.userId) },
      });

      if (!user) {
        return {
          success: false,
          message: 'User not found',
        };
      }

      // Update fields if provided
      if (data.firstName) user.firstName = data.firstName;
      if (data.lastName) user.lastName = data.lastName;
      if (data.username) user.username = data.username;

      const updatedUser = await this.userRepository.save(user);

      return {
        success: true,
        message: 'User profile updated successfully',
        user: this.formatUserData(updatedUser),
      };
    } catch (error) {
      logger.error('Update user profile failed:', error);
      throw error;
    }
  }

  private async generateTokens(user: User) {
    const payload = { userId: user.id, email: user.email };

    const accessToken = this.jwtService.sign(payload, {
      secret: process.env.JWT_SECRET || 'your-secret-key',
      expiresIn: '15m',
    });

    const refreshToken = this.jwtService.sign(
      { ...payload, type: 'refresh' },
      {
        secret: process.env.JWT_REFRESH_SECRET || 'your-refresh-secret',
        expiresIn: '7d',
      }
    );

    return { accessToken, refreshToken };
  }

  private async saveRefreshToken(userId: number, refreshToken: string) {
    const refreshTokenHash = await bcrypt.hash(refreshToken, 12);
    const refreshTokenExpiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await this.userRepository.update(userId, {
      refreshTokenHash,
      refreshTokenExpiresAt,
    });
  }

  private formatUserData(user: User) {
    return {
      id: user.id.toString(),
      username: user.username,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      roles: user.roles,
      createdAt: user.createdAt.toISOString(),
      updatedAt: user.updatedAt.toISOString(),
    };
  }
}
```

### **services/auth-service-nestjs/src/auth/auth.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { User } from '../users/entities/user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [AuthController],
  providers: [AuthService],
  exports: [AuthService],
})
export class AuthModule {}
```

***

# Day 9: API Gateway Implementation

## Step 5: NestJS API Gateway

### **services/api-gateway/package.json**
```json
{
  "name": "@aether/api-gateway",
  "version": "1.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "nest build",
    "dev": "nest start --watch",
    "start": "node dist/main",
    "test": "jest",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix"
  },
  "dependencies": {
    "@nestjs/common": "^10.2.7",
    "@nestjs/core": "^10.2.7",
    "@nestjs/platform-express": "^10.2.7",
    "@nestjs/microservices": "^10.2.7",
    "@nestjs/swagger": "^7.1.14",
    "@nestjs/config": "^3.1.1",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.3",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "@grpc/grpc-js": "^1.9.7",
    "@grpc/proto-loader": "^0.7.10",
    "@aether/shared": "workspace:*"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.1.18",
    "@nestjs/testing": "^10.2.7",
    "typescript": "^5.2.2",
    "@types/node": "^20.8.0",
    "jest": "^29.7.0"
  }
}
```

### **services/api-gateway/src/main.ts**
```typescript
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { AppModule } from './app.module';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('api-gateway');

async function bootstrap() {
  try {
    const app = await NestFactory.create(AppModule);

    // Security middleware
    app.use(helmet());

    // Rate limiting
    app.use(
      rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // limit each IP to 100 requests per windowMs
        message: 'Too many requests from this IP, please try again later.',
      }),
    );

    // CORS
    app.enableCors({
      origin: process.env.FRONTEND_URL || 'http://localhost:3004',
      credentials: true,
    });

    // Global validation pipe
    app.useGlobalPipes(new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
    }));

    // Swagger documentation
    const config = new DocumentBuilder()
      .setTitle('AetherConnect API')
      .setDescription('Enterprise-grade chat application API')
      .setVersion('1.0')
      .addBearerAuth()
      .build();
    
    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api/docs', app, document);

    const port = process.env.API_GATEWAY_PORT || 3000;
    await app.listen(port);

    logger.info(`üöÄ API Gateway is running on http://localhost:${port}`);
    logger.info(`üìö Swagger docs available at http://localhost:${port}/api/docs`);
    logger.info(`üîó Health check: http://localhost:${port}/api/health`);

  } catch (error) {
    logger.error('Failed to start API Gateway:', error);
    process.exit(1);
  }
}

bootstrap();
```

### **services/api-gateway/src/app.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AuthModule } from './auth/auth.module';
import { HealthModule } from './health/health.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '../../../.env',
    }),
    AuthModule,
    HealthModule,
  ],
})
export class AppModule {}
```

### **services/api-gateway/src/auth/auth.controller.ts**
```typescript
import { Controller, Post, Get, Put, Body, UseGuards, Request } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { AuthService } from './auth.service';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { CreateUserDto, LoginDto, UpdateUserDto } from './dto/auth.dto';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('auth-controller-gateway');

@ApiTags('Authentication')
@Controller('api/auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'Register a new user' })
  @ApiResponse({ status: 201, description: 'User created successfully' })
  @ApiResponse({ status: 400, description: 'Invalid input data' })
  async register(@Body() createUserDto: CreateUserDto) {
    logger.info('Register request received', { email: createUserDto.email });
    const result = await this.authService.register(createUserDto);
    logger.info('Register request completed', { success: result.success });
    return result;
  }

  @Post('login')
  @ApiOperation({ summary: 'Login user' })
  @ApiResponse({ status: 200, description: 'Login successful' })
  @ApiResponse({ status: 401, description: 'Invalid credentials' })
  async login(@Body() loginDto: LoginDto) {
    logger.info('Login request received', { email: loginDto.email });
    const result = await this.authService.login(loginDto);
    logger.info('Login request completed', { success: result.success });
    return result;
  }

  @Post('refresh')
  @ApiOperation({ summary: 'Refresh access token' })
  @ApiResponse({ status: 200, description: 'Token refreshed successfully' })
  @ApiResponse({ status: 401, description: 'Invalid refresh token' })
  async refreshToken(@Body() body: { refreshToken: string }) {
    logger.info('Refresh token request received');
    const result = await this.authService.refreshToken(body.refreshToken);
    logger.info('Refresh token request completed', { success: result.success });
    return result;
  }

  @Get('profile')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Get user profile' })
  @ApiResponse({ status: 200, description: 'Profile retrieved successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async getProfile(@Request() req) {
    logger.info('Get profile request received', { userId: req.user.userId });
    const result = await this.authService.getUserProfile(req.user.userId);
    logger.info('Get profile request completed', { success: result.success });
    return result;
  }

  @Put('profile')
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  @ApiOperation({ summary: 'Update user profile' })
  @ApiResponse({ status: 200, description: 'Profile updated successfully' })
  @ApiResponse({ status: 401, description: 'Unauthorized' })
  async updateProfile(@Request() req, @Body() updateUserDto: UpdateUserDto) {
    logger.info('Update profile request received', { userId: req.user.userId });
    const result = await this.authService.updateUserProfile(req.user.userId, updateUserDto);
    logger.info('Update profile request completed', { success: result.success });
    return result;
  }
}
```

### **services/api-gateway/src/auth/auth.service.ts**
```typescript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { AuthGrpcClient } from '@aether/shared';
import { CreateUserDto, LoginDto, UpdateUserDto } from './dto/auth.dto';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('auth-service-gateway');

@Injectable()
export class AuthService implements OnModuleInit {
  private authClient: AuthGrpcClient;

  onModuleInit() {
    const authServiceUrl = process.env.AUTH_SERVICE_GRPC_URL || 'localhost:50001';
    this.authClient = new AuthGrpcClient(authServiceUrl);
    logger.info(`Connected to Auth Service at ${authServiceUrl}`);
  }

  async register(createUserDto: CreateUserDto) {
    try {
      return await this.authClient.CreateUser(createUserDto);
    } catch (error) {
      logger.error('Register gRPC call failed:', error);
      return {
        success: false,
        message: 'Registration failed',
        error: 'Internal server error',
      };
    }
  }

  async login(loginDto: LoginDto) {
    try {
      return await this.authClient.Login(loginDto);
    } catch (error) {
      logger.error('Login gRPC call failed:', error);
      return {
        success: false,
        message: 'Login failed',
        error: 'Internal server error',
      };
    }
  }

  async validateToken(token: string) {
    try {
      return await this.authClient.ValidateToken({ token });
    } catch (error) {
      logger.error('ValidateToken gRPC call failed:', error);
      return {
        success: false,
        message: 'Token validation failed',
        isValid: false,
      };
    }
  }

  async refreshToken(refreshToken: string) {
    try {
      return await this.authClient.RefreshToken({ refreshToken });
    } catch (error) {
      logger.error('RefreshToken gRPC call failed:', error);
      return {
        success: false,
        message: 'Token refresh failed',
        error: 'Internal server error',
      };
    }
  }

  async getUserProfile(userId: string) {
    try {
      return await this.authClient.GetUserProfile({ userId });
    } catch (error) {
      logger.error('GetUserProfile gRPC call failed:', error);
      return {
        success: false,
        message: 'Failed to get user profile',
        error: 'Internal server error',
      };
    }
  }

  async updateUserProfile(userId: string, updateUserDto: UpdateUserDto) {
    try {
      return await this.authClient.UpdateUserProfile({
        userId,
        ...updateUserDto,
      });
    } catch (error) {
      logger.error('UpdateUserProfile gRPC call failed:', error);
      return {
        success: false,
        message: 'Failed to update user profile',
        error: 'Internal server error',
      };
    }
  }
}
```

### **services/api-gateway/src/auth/dto/auth.dto.ts**
```typescript
import { IsEmail, IsString, MinLength, IsOptional } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateUserDto {
  @ApiProperty({ example: 'john_doe', description: 'Username (3-50 characters)' })
  @IsString()
  @MinLength(3)
  username: string;

  @ApiProperty({ example: 'john@example.com', description: 'User email address' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: 'securepass123', description: 'Password (minimum 8 characters)' })
  @IsString()
  @MinLength(8)
  password: string;

  @ApiProperty({ example: 'John', description: 'First name' })
  @IsString()
  firstName: string;

  @ApiProperty({ example: 'Doe', description: 'Last name' })
  @IsString()
  lastName: string;
}

export class LoginDto {
  @ApiProperty({ example: 'john@example.com', description: 'User email address' })
  @IsEmail()
  email: string;

  @ApiProperty({ example: 'securepass123', description: 'User password' })
  @IsString()
  password: string;
}

export class UpdateUserDto {
  @ApiPropertyOptional({ example: 'John', description: 'First name' })
  @IsOptional()
  @IsString()
  firstName?: string;

  @ApiPropertyOptional({ example: 'Doe', description: 'Last name' })
  @IsOptional()
  @IsString()
  lastName?: string;

  @ApiPropertyOptional({ example: 'john_doe_updated', description: 'Username' })
  @IsOptional()
  @IsString()
  @MinLength(3)
  username?: string;
}
```

### **services/api-gateway/src/auth/guards/jwt-auth.guard.ts**
```typescript
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthService } from '../auth.service';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('jwt-auth-guard');

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private readonly authService: AuthService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    
    const authHeader = request.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      logger.warn('No authorization header or invalid format');
      throw new UnauthorizedException('Access token required');
    }

    const token = authHeader.substring(7);
    
    try {
      const result = await this.authService.validateToken(token);
      
      if (!result.success || !result.isValid) {
        logger.warn('Token validation failed');
        throw new UnauthorizedException('Invalid token');
      }

      request.user = {
        userId: result.user.id,
        email: result.user.email,
        username: result.user.username,
      };

      return true;
    } catch (error) {
      logger.error('Token validation error:', error);
      throw new UnauthorizedException('Token validation failed');
    }
  }
}
```

### **services/api-gateway/src/auth/auth.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

@Module({
  controllers: [AuthController],
  providers: [AuthService, JwtAuthGuard],
  exports: [AuthService, JwtAuthGuard],
})
export class AuthModule {}
```

## Step 6: Health Check Module

### **services/api-gateway/src/health/health.controller.ts**
```typescript
import { Controller, Get } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';
import { HealthService } from './health.service';

@ApiTags('Health')
@Controller('api/health')
export class HealthController {
  constructor(private readonly healthService: HealthService) {}

  @Get()
  @ApiOperation({ summary: 'Health check endpoint' })
  async getHealth() {
    return this.healthService.getHealth();
  }

  @Get('detailed')
  @ApiOperation({ summary: 'Detailed health check with service dependencies' })
  async getDetailedHealth() {
    return this.healthService.getDetailedHealth();
  }
}
```

### **services/api-gateway/src/health/health.service.ts**
```typescript
import { Injectable } from '@nestjs/common';
import { AuthGrpcClient } from '@aether/shared';

@Injectable()
export class HealthService {
  async getHealth() {
    return {
      status: 'OK',
      service: 'api-gateway',
      version: '1.0.0',
      timestamp: new Date().toISOString(),
    };
  }

  async getDetailedHealth() {
    const health = {
      status: 'OK',
      service: 'api-gateway',
      version: '1.0.0',
      timestamp: new Date().toISOString(),
      dependencies: {
        authService: await this.checkAuthService(),
      },
    };

    return health;
  }

  private async checkAuthService(): Promise<{ status: string; latency?: number }> {
    try {
      const start = Date.now();
      const authClient = new AuthGrpcClient(process.env.AUTH_SERVICE_GRPC_URL || 'localhost:50001');
      await authClient.HealthCheck();
      const latency = Date.now() - start;

      return { status: 'OK', latency };
    } catch (error) {
      return { status: 'ERROR' };
    }
  }
}
```

### **services/api-gateway/src/health/health.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { HealthController } from './health.controller';
import { HealthService } from './health.service';

@Module({
  controllers: [HealthController],
  providers: [HealthService],
})
export class HealthModule {}
```

## Step 7: Update Environment & Root Configuration

### **Update .env file**
```env
# Node Environment
NODE_ENV=development
LOG_LEVEL=debug

# Database URLs
POSTGRES_URL=postgresql://aether:secret123@localhost:5432/aetherconnect

# JWT Configuration
JWT_SECRET=your-super-secret-access-key-change-in-production-2025
JWT_REFRESH_SECRET=your-super-secret-refresh-key-change-in-production-2025

# Service Ports
API_GATEWAY_PORT=3000
AUTH_SERVICE_GRPC_PORT=50001

# Service URLs
AUTH_SERVICE_GRPC_URL=localhost:50001

# Frontend
FRONTEND_URL=http://localhost:3004
```

### **Update Root package.json**
```json
{
  "name": "aetherconnect",
  "version": "1.0.0",
  "private": true,
  "workspaces": ["services/*", "packages/*"],
  "scripts": {
    "dev": "concurrently \"pnpm dev:auth\" \"pnpm dev:gateway\"",
    "dev:auth": "pnpm --filter @aether/auth-service-nestjs run dev",
    "dev:gateway": "pnpm --filter @aether/api-gateway run dev",
    "build": "pnpm -r run build",
    "docker:up": "docker-compose up -d",
    "setup": "pnpm install && pnpm docker:up && sleep 5"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}
```

## Step 8: Setup & Testing Commands

```bash
# 1. Build shared package
cd packages/shared
pnpm install && pnpm build
cd ../..

# 2. Install all service dependencies
pnpm install

# 3. Start infrastructure
pnpm docker:up

# 4. Start both services
pnpm dev

# In separate terminals, you should see:
# üîê Auth Service (gRPC) is listening on port 50001
# üöÄ API Gateway is running on http://localhost:3000
```

## Step 9: Test Your Microservices Architecture

### **Test Registration via API Gateway:**
```bash
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "email": "test@example.com",
    "password": "password123",
    "firstName": "Test",
    "lastName": "User"
  }'
```

### **Test Login:**
```bash
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

### **Test Protected Route:**
```bash
# Use the access token from login response
curl -X GET http://localhost:3000/api/auth/profile \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN_HERE"
```

### **Test Health Checks:**
```bash
# API Gateway health
curl http://localhost:3000/api/health

# Detailed health (includes Auth Service check)
curl http://localhost:3000/api/health/detailed
```

## Phase 3 Success Criteria

By the end of Day 9, you should have:

‚úÖ **NestJS Auth Service** running on gRPC (port 50001)  
‚úÖ **NestJS API Gateway** running on HTTP (port 3000)  
‚úÖ **Protocol Buffers** defining service contracts  
‚úÖ **Type-safe gRPC communication** between services  
‚úÖ **Proper error handling** and logging  
‚úÖ **JWT authentication** working through microservices  
‚úÖ **Swagger documentation** available at `/api/docs`  
‚úÖ **Health checks** for service monitoring  

## What You Now Have

- **True microservices architecture** with NestJS
- **Service-to-service communication** via gRPC  
- **HTTP API Gateway** that routes to microservices
- **Type safety** across service boundaries
- **Enterprise-grade error handling** and logging
- **Production-ready patterns** for scaling

**Your frontend can now connect to the same endpoints, but they're powered by microservices!** üéâ

Ready for **Phase 4: WebSocket Messaging Service**? üöÄ