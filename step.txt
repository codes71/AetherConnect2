# AetherConnect Development Plan: 10 Phases for 1-Month Timeline

Based on our comprehensive analysis of the AetherConnect project, here's a structured 10-phase development plan that will get you from foundation to production-ready system within 30 days.[1][2]

## Phase Overview (1-Month Timeline)

Phase	Days	Core Focus	What You'll See Working
Phase 1	1-3	Single service + DB working	Auth service responding via HTTP
Phase 2	4-6	JWT auth + user management	Login/register working
Phase 3	7-9	API Gateway + gRPC microservices	NestJS API Gateway and Auth microservice communicating via gRPC
Phase 4	10-12	WebSocket Messaging Service with real-time chat	Live real-time messaging in chat app terminal and frontend
Phase 5	13-15	Frontend integration with Next.js and backend services	Fully functional frontend connected to backend via REST and WebSocket
Phase 6	16-18	Multi-room + file upload	Chat rooms + file sharing
Phase 7	19-21	Kafka events + notifications	Event-driven architecture
Phase 8	22-24	AI moderation + Redis caching	Content filtering working
Phase 9	25-27	Observability (metrics/logs)	Monitoring dashboards
Phase 10	28-30	Production deployment	Kubernetes + CI/CD

# Phase 3 Complete - Moving to Phase 4!

**Amazing work!** Your microservices architecture with NestJS + gRPC is now solid. Time for **Phase 4: WebSocket Messaging Service** - this is where your chat app comes to life with real-time messaging!

***

# Phase 4: WebSocket Messaging Service (Days 10-12)

## Phase 4 Goals
**Build a real-time messaging system** with Socket.io, MongoDB message persistence, and Redis for horizontal scaling.

### What You'll Accomplish:
- **Message Service** (NestJS + gRPC) with Socket.io gateway
- **MongoDB integration** for message persistence  
- **Redis adapter** for Socket.io horizontal scaling
- **Real-time messaging** between clients
- **Message history** with pagination
- **Integration** with Auth Service for user validation

***

# Day 10: Message Service Setup & TypeScript Configs

## Step 1: All Required TypeScript Configurations

### **Root tsconfig.json**
```json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "es2017",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "paths": {
      "@aether/shared/*": ["packages/shared/src/*"],
      "@aether/protos/*": ["packages/protos/*"]
    }
  },
  "exclude": ["node_modules", "dist"]
}
```

### **packages/shared/tsconfig.json**
```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

### **services/auth-service-nestjs/tsconfig.json**
```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### **services/api-gateway/tsconfig.json**
```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

## Step 2: Update Docker Compose with MongoDB & Redis

### **docker-compose.yml** (Updated)
```yaml
version: '3.8'

services:
  # PostgreSQL for Auth Service
  postgres:
    image: postgres:15-alpine
    container_name: aether-postgres
    environment:
      POSTGRES_DB: aetherconnect
      POSTGRES_USER: aether
      POSTGRES_PASSWORD: secret123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U aether -d aetherconnect"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - aether-network

  # MongoDB for Message Service
  mongodb:
    image: mongo:7.0
    container_name: aether-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: aether
      MONGO_INITDB_ROOT_PASSWORD: secret123
      MONGO_INITDB_DATABASE: aetherconnect
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - aether-network

  # Redis for Socket.io and Caching
  redis:
    image: redis:7-alpine
    container_name: aether-redis
    command: redis-server --appendonly yes --requirepass secret123
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - aether-network

volumes:
  postgres_data:
  mongodb_data:
  redis_data:

networks:
  aether-network:
    driver: bridge
    name: aetherconnect-network
```

## Step 3: Update Protobuf Definitions

### **packages/protos/message.proto** (NEW)
```protobuf
syntax = "proto3";

package message;

service MessageService {
  rpc SendMessage(SendMessageRequest) returns (MessageResponse);
  rpc GetMessageHistory(GetMessageHistoryRequest) returns (MessageHistoryResponse);
  rpc GetRooms(GetRoomsRequest) returns (RoomsResponse);
  rpc CreateRoom(CreateRoomRequest) returns (RoomResponse);
  rpc JoinRoom(JoinRoomRequest) returns (RoomResponse);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
}

message SendMessageRequest {
  string userId = 1;
  string roomId = 2;
  string content = 3;
  string messageType = 4; // text, image, file
  optional string metadata = 5;
}

message GetMessageHistoryRequest {
  string roomId = 1;
  string userId = 2;
  int32 page = 3;
  int32 limit = 4;
}

message GetRoomsRequest {
  string userId = 1;
}

message CreateRoomRequest {
  string name = 1;
  string description = 2;
  string createdBy = 3;
  string roomType = 4; // public, private, direct
}

message JoinRoomRequest {
  string userId = 1;
  string roomId = 2;
}

message HealthCheckRequest {}

message MessageResponse {
  bool success = 1;
  string message = 2;
  optional MessageData messageData = 3;
  optional string error = 4;
}

message MessageHistoryResponse {
  bool success = 1;
  string message = 2;
  repeated MessageData messages = 3;
  optional PaginationInfo pagination = 4;
  optional string error = 5;
}

message RoomsResponse {
  bool success = 1;
  string message = 2;
  repeated RoomData rooms = 3;
  optional string error = 4;
}

message RoomResponse {
  bool success = 1;
  string message = 2;
  optional RoomData room = 3;
  optional string error = 4;
}

message HealthCheckResponse {
  bool success = 1;
  string message = 2;
  string service = 3;
  string version = 4;
  string timestamp = 5;
}

message MessageData {
  string id = 1;
  string userId = 2;
  string username = 3;
  string roomId = 4;
  string content = 5;
  string messageType = 6;
  optional string metadata = 7;
  string createdAt = 8;
  string updatedAt = 9;
}

message RoomData {
  string id = 1;
  string name = 2;
  string description = 3;
  string roomType = 4;
  string createdBy = 5;
  repeated string members = 6;
  string createdAt = 7;
  string updatedAt = 8;
}

message PaginationInfo {
  int32 currentPage = 1;
  int32 totalPages = 2;
  int32 totalItems = 3;
  int32 itemsPerPage = 4;
  bool hasNext = 5;
  bool hasPrevious = 6;
}
```

## Step 4: Message Service Implementation

### **services/message-service/package.json**
```json
{
  "name": "@aether/message-service",
  "version": "1.0.0",
  "main": "dist/main.js",
  "scripts": {
    "build": "nest build",
    "dev": "nest start --watch",
    "start": "node dist/main",
    "test": "jest",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix"
  },
  "dependencies": {
    "@nestjs/common": "^10.2.7",
    "@nestjs/core": "^10.2.7",
    "@nestjs/microservices": "^10.2.7",
    "@nestjs/platform-socket.io": "^10.2.7",
    "@nestjs/websockets": "^10.2.7",
    "@nestjs/mongoose": "^10.0.2",
    "@nestjs/config": "^3.1.1",
    "mongoose": "^7.6.3",
    "socket.io": "^4.7.4",
    "socket.io-redis": "^6.1.1",
    "ioredis": "^5.3.2",
    "class-validator": "^0.14.0",
    "class-transformer": "^0.5.1",
    "reflect-metadata": "^0.1.13",
    "rxjs": "^7.8.1",
    "@grpc/grpc-js": "^1.9.7",
    "@grpc/proto-loader": "^0.7.10",
    "@aether/shared": "workspace:*",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.1.18",
    "@nestjs/testing": "^10.2.7",
    "typescript": "^5.2.2",
    "@types/node": "^20.8.0",
    "@types/uuid": "^9.0.5",
    "jest": "^29.7.0"
  }
}
```

### **services/message-service/tsconfig.json**
```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### **services/message-service/nest-cli.json**
```json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
```

### **services/message-service/src/main.ts**
```typescript
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { join } from 'path';
import { AppModule } from './app.module';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('message-service');

async function bootstrap() {
  try {
    // Create gRPC microservice
    const grpcApp = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
      transport: Transport.GRPC,
      options: {
        package: 'message',
        protoPath: join(__dirname, '../../../packages/protos/message.proto'),
        url: `0.0.0.0:${process.env.MESSAGE_SERVICE_GRPC_PORT || 50002}`,
        loader: {
          keepCase: true,
          longs: String,
          enums: String,
          defaults: true,
          oneofs: true,
        },
      },
    });

    // Create HTTP app for Socket.io
    const httpApp = await NestFactory.create(AppModule);
    
    // Enable CORS for Socket.io
    httpApp.enableCors({
      origin: process.env.FRONTEND_URL || 'http://localhost:3004',
      credentials: true,
    });

    // Start both services
    await Promise.all([
      grpcApp.listen(),
      httpApp.listen(process.env.MESSAGE_SERVICE_HTTP_PORT || 3002)
    ]);

    const grpcPort = process.env.MESSAGE_SERVICE_GRPC_PORT || 50002;
    const httpPort = process.env.MESSAGE_SERVICE_HTTP_PORT || 3002;
    
    logger.info(`üí¨ Message Service (gRPC) is listening on port ${grpcPort}`);
    logger.info(`üåê Message Service (Socket.io) is listening on port ${httpPort}`);

    // Graceful shutdown
    process.on('SIGTERM', async () => {
      logger.info('SIGTERM received, shutting down gracefully');
      await Promise.all([grpcApp.close(), httpApp.close()]);
      process.exit(0);
    });

  } catch (error) {
    logger.error('Failed to start Message Service:', error);
    process.exit(1);
  }
}

bootstrap();
```

### **services/message-service/src/app.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { MessageModule } from './message/message.module';
import { SocketModule } from './socket/socket.module';
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '../../../.env',
    }),
    DatabaseModule,
    MessageModule,
    SocketModule,
  ],
})
export class AppModule {}
```

### **services/message-service/src/database/database.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [
    MongooseModule.forRoot(
      process.env.MONGODB_URL || 'mongodb://aether:secret123@localhost:27017/aetherconnect',
      {
        authSource: 'admin',
      }
    ),
  ],
})
export class DatabaseModule {}
```

## Step 5: Message Schemas and Entities

### **services/message-service/src/message/schemas/message.schema.ts**
```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type MessageDocument = Message & Document;

@Schema({ timestamps: true })
export class Message {
  @Prop({ required: true })
  userId: string;

  @Prop({ required: true })
  username: string;

  @Prop({ required: true })
  roomId: string;

  @Prop({ required: true })
  content: string;

  @Prop({ required: true, enum: ['text', 'image', 'file'], default: 'text' })
  messageType: string;

  @Prop({ type: Object, required: false })
  metadata?: any;

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updatedAt: Date;
}

export const MessageSchema = SchemaFactory.createForClass(Message);

// Add indexes for better query performance
MessageSchema.index({ roomId: 1, createdAt: -1 });
MessageSchema.index({ userId: 1, createdAt: -1 });
```

### **services/message-service/src/message/schemas/room.schema.ts**
```typescript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

export type RoomDocument = Room & Document;

@Schema({ timestamps: true })
export class Room {
  @Prop({ required: true })
  name: string;

  @Prop()
  description: string;

  @Prop({ required: true, enum: ['public', 'private', 'direct'], default: 'public' })
  roomType: string;

  @Prop({ required: true })
  createdBy: string;

  @Prop({ type: [String], default: [] })
  members: string[];

  @Prop({ default: Date.now })
  createdAt: Date;

  @Prop({ default: Date.now })
  updatedAt: Date;
}

export const RoomSchema = SchemaFactory.createForClass(Room);

// Add indexes
RoomSchema.index({ createdBy: 1 });
RoomSchema.index({ members: 1 });
RoomSchema.index({ roomType: 1 });
```

## Step 6: Socket.io Gateway

### **services/message-service/src/socket/socket.gateway.ts**
```typescript
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  WebSocketServer,
  OnGatewayConnection,
  OnGatewayDisconnect,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Injectable } from '@nestjs/common';
import { AuthGrpcClient, createServiceLogger } from '@aether/shared';
import { MessageService } from '../message/message.service';
import Redis from 'ioredis';
import { createAdapter } from 'socket.io-redis';

const logger = createServiceLogger('socket-gateway');

@Injectable()
@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3004',
    credentials: true,
  },
})
export class SocketGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private authClient: AuthGrpcClient;
  private connectedUsers = new Map<string, { userId: string; username: string; rooms: Set<string> }>();

  constructor(private readonly messageService: MessageService) {
    // Initialize Auth gRPC client
    this.authClient = new AuthGrpcClient(process.env.AUTH_SERVICE_GRPC_URL || 'localhost:50001');
    
    // Setup Redis adapter for Socket.io clustering
    this.setupRedisAdapter();
  }

  private setupRedisAdapter() {
    const redisUrl = process.env.REDIS_URL || 'redis://:secret123@localhost:6379';
    const pubClient = new Redis(redisUrl);
    const subClient = pubClient.duplicate();
    
    this.server?.adapter(createAdapter(pubClient, subClient));
    logger.info('Redis adapter configured for Socket.io clustering');
  }

  async handleConnection(client: Socket) {
    try {
      logger.info('Client attempting to connect', { socketId: client.id });
      
      const token = client.handshake.auth?.token;
      if (!token) {
        logger.warn('Connection rejected: No token provided', { socketId: client.id });
        client.emit('error', { message: 'Authentication required' });
        client.disconnect();
        return;
      }

      // Validate token with Auth Service
      const authResult = await this.authClient.ValidateToken({ token });
      
      if (!authResult.success || !authResult.isValid) {
        logger.warn('Connection rejected: Invalid token', { socketId: client.id });
        client.emit('error', { message: 'Invalid token' });
        client.disconnect();
        return;
      }

      // Store user connection info
      this.connectedUsers.set(client.id, {
        userId: authResult.user.id,
        username: authResult.user.username,
        rooms: new Set(),
      });

      client.emit('connected', {
        message: 'Successfully connected',
        user: {
          id: authResult.user.id,
          username: authResult.user.username,
        },
      });

      logger.info('Client connected successfully', {
        socketId: client.id,
        userId: authResult.user.id,
        username: authResult.user.username,
      });

    } catch (error) {
      logger.error('Connection error:', error);
      client.emit('error', { message: 'Connection failed' });
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    const userInfo = this.connectedUsers.get(client.id);
    if (userInfo) {
      // Leave all rooms
      userInfo.rooms.forEach(roomId => {
        client.leave(roomId);
        client.to(roomId).emit('user_left', {
          userId: userInfo.userId,
          username: userInfo.username,
          roomId,
        });
      });

      this.connectedUsers.delete(client.id);
      
      logger.info('Client disconnected', {
        socketId: client.id,
        userId: userInfo.userId,
        username: userInfo.username,
      });
    }
  }

  @SubscribeMessage('join_room')
  async handleJoinRoom(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      const userInfo = this.connectedUsers.get(client.id);
      if (!userInfo) {
        client.emit('error', { message: 'User not authenticated' });
        return;
      }

      await client.join(data.roomId);
      userInfo.rooms.add(data.roomId);

      // Notify other users in the room
      client.to(data.roomId).emit('user_joined', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
      });

      client.emit('joined_room', {
        message: `Joined room ${data.roomId}`,
        roomId: data.roomId,
      });

      logger.info('User joined room', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
      });

    } catch (error) {
      logger.error('Error joining room:', error);
      client.emit('error', { message: 'Failed to join room' });
    }
  }

  @SubscribeMessage('leave_room')
  async handleLeaveRoom(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      const userInfo = this.connectedUsers.get(client.id);
      if (!userInfo) return;

      await client.leave(data.roomId);
      userInfo.rooms.delete(data.roomId);

      // Notify other users in the room
      client.to(data.roomId).emit('user_left', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
      });

      client.emit('left_room', {
        message: `Left room ${data.roomId}`,
        roomId: data.roomId,
      });

      logger.info('User left room', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
      });

    } catch (error) {
      logger.error('Error leaving room:', error);
      client.emit('error', { message: 'Failed to leave room' });
    }
  }

  @SubscribeMessage('send_message')
  async handleMessage(
    @MessageBody() data: { roomId: string; content: string; messageType?: string },
    @ConnectedSocket() client: Socket,
  ) {
    try {
      const userInfo = this.connectedUsers.get(client.id);
      if (!userInfo) {
        client.emit('error', { message: 'User not authenticated' });
        return;
      }

      if (!userInfo.rooms.has(data.roomId)) {
        client.emit('error', { message: 'You are not in this room' });
        return;
      }

      // Save message to database via gRPC
      const messageResult = await this.messageService.sendMessage({
        userId: userInfo.userId,
        roomId: data.roomId,
        content: data.content,
        messageType: data.messageType || 'text',
      });

      if (!messageResult.success) {
        client.emit('error', { message: 'Failed to send message' });
        return;
      }

      const messageData = {
        id: messageResult.messageData.id,
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
        content: data.content,
        messageType: data.messageType || 'text',
        createdAt: new Date().toISOString(),
      };

      // Broadcast to all users in the room (including sender)
      this.server.to(data.roomId).emit('new_message', messageData);

      logger.info('Message sent', {
        messageId: messageResult.messageData.id,
        userId: userInfo.userId,
        roomId: data.roomId,
        contentLength: data.content.length,
      });

    } catch (error) {
      logger.error('Error sending message:', error);
      client.emit('error', { message: 'Failed to send message' });
    }
  }

  @SubscribeMessage('typing_start')
  handleTypingStart(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    const userInfo = this.connectedUsers.get(client.id);
    if (userInfo && userInfo.rooms.has(data.roomId)) {
      client.to(data.roomId).emit('user_typing', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
        isTyping: true,
      });
    }
  }

  @SubscribeMessage('typing_stop')
  handleTypingStop(
    @MessageBody() data: { roomId: string },
    @ConnectedSocket() client: Socket,
  ) {
    const userInfo = this.connectedUsers.get(client.id);
    if (userInfo && userInfo.rooms.has(data.roomId)) {
      client.to(data.roomId).emit('user_typing', {
        userId: userInfo.userId,
        username: userInfo.username,
        roomId: data.roomId,
        isTyping: false,
      });
    }
  }
}
```

## Step 7: Message Service Implementation

### **services/message-service/src/message/message.service.ts**
```typescript
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Message, MessageDocument } from './schemas/message.schema';
import { Room, RoomDocument } from './schemas/room.schema';
import { createServiceLogger } from '@aether/shared';
import { v4 as uuidv4 } from 'uuid';

const logger = createServiceLogger('message-service-logic');

@Injectable()
export class MessageService {
  constructor(
    @InjectModel(Message.name) private messageModel: Model<MessageDocument>,
    @InjectModel(Room.name) private roomModel: Model<RoomDocument>,
  ) {}

  async sendMessage(data: any) {
    try {
      const message = new this.messageModel({
        userId: data.userId,
        username: data.username || 'Unknown',
        roomId: data.roomId,
        content: data.content,
        messageType: data.messageType || 'text',
        metadata: data.metadata,
      });

      const savedMessage = await message.save();

      return {
        success: true,
        message: 'Message sent successfully',
        messageData: {
          id: savedMessage._id.toString(),
          userId: savedMessage.userId,
          username: savedMessage.username,
          roomId: savedMessage.roomId,
          content: savedMessage.content,
          messageType: savedMessage.messageType,
          metadata: savedMessage.metadata,
          createdAt: savedMessage.createdAt.toISOString(),
          updatedAt: savedMessage.updatedAt.toISOString(),
        },
      };
    } catch (error) {
      logger.error('Send message failed:', error);
      return {
        success: false,
        message: 'Failed to send message',
        error: error.message,
      };
    }
  }

  async getMessageHistory(data: any) {
    try {
      const page = parseInt(data.page) || 1;
      const limit = Math.min(parseInt(data.limit) || 50, 100); // Max 100 messages per request
      const skip = (page - 1) * limit;

      const messages = await this.messageModel
        .find({ roomId: data.roomId })
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit)
        .exec();

      const totalMessages = await this.messageModel.countDocuments({ roomId: data.roomId });
      const totalPages = Math.ceil(totalMessages / limit);

      return {
        success: true,
        message: 'Message history retrieved successfully',
        messages: messages.reverse().map(msg => ({
          id: msg._id.toString(),
          userId: msg.userId,
          username: msg.username,
          roomId: msg.roomId,
          content: msg.content,
          messageType: msg.messageType,
          metadata: msg.metadata,
          createdAt: msg.createdAt.toISOString(),
          updatedAt: msg.updatedAt.toISOString(),
        })),
        pagination: {
          currentPage: page,
          totalPages,
          totalItems: totalMessages,
          itemsPerPage: limit,
          hasNext: page < totalPages,
          hasPrevious: page > 1,
        },
      };
    } catch (error) {
      logger.error('Get message history failed:', error);
      return {
        success: false,
        message: 'Failed to get message history',
        error: error.message,
      };
    }
  }

  async createRoom(data: any) {
    try {
      const room = new this.roomModel({
        name: data.name,
        description: data.description,
        roomType: data.roomType || 'public',
        createdBy: data.createdBy,
        members: [data.createdBy],
      });

      const savedRoom = await room.save();

      return {
        success: true,
        message: 'Room created successfully',
        room: {
          id: savedRoom._id.toString(),
          name: savedRoom.name,
          description: savedRoom.description,
          roomType: savedRoom.roomType,
          createdBy: savedRoom.createdBy,
          members: savedRoom.members,
          createdAt: savedRoom.createdAt.toISOString(),
          updatedAt: savedRoom.updatedAt.toISOString(),
        },
      };
    } catch (error) {
      logger.error('Create room failed:', error);
      return {
        success: false,
        message: 'Failed to create room',
        error: error.message,
      };
    }
  }

  async getRooms(data: any) {
    try {
      const rooms = await this.roomModel
        .find({ 
          $or: [
            { members: data.userId },
            { roomType: 'public' }
          ]
        })
        .sort({ updatedAt: -1 })
        .exec();

      return {
        success: true,
        message: 'Rooms retrieved successfully',
        rooms: rooms.map(room => ({
          id: room._id.toString(),
          name: room.name,
          description: room.description,
          roomType: room.roomType,
          createdBy: room.createdBy,
          members: room.members,
          createdAt: room.createdAt.toISOString(),
          updatedAt: room.updatedAt.toISOString(),
        })),
      };
    } catch (error) {
      logger.error('Get rooms failed:', error);
      return {
        success: false,
        message: 'Failed to get rooms',
        error: error.message,
      };
    }
  }

  async joinRoom(data: any) {
    try {
      const room = await this.roomModel.findById(data.roomId);
      
      if (!room) {
        return {
          success: false,
          message: 'Room not found',
        };
      }

      if (!room.members.includes(data.userId)) {
        room.members.push(data.userId);
        await room.save();
      }

      return {
        success: true,
        message: 'Joined room successfully',
        room: {
          id: room._id.toString(),
          name: room.name,
          description: room.description,
          roomType: room.roomType,
          createdBy: room.createdBy,
          members: room.members,
          createdAt: room.createdAt.toISOString(),
          updatedAt: room.updatedAt.toISOString(),
        },
      };
    } catch (error) {
      logger.error('Join room failed:', error);
      return {
        success: false,
        message: 'Failed to join room',
        error: error.message,
      };
    }
  }
}
```

## Step 8: Message gRPC Controller

### **services/message-service/src/message/message.controller.ts**
```typescript
import { Controller } from '@nestjs/common';
import { GrpcMethod } from '@nestjs/microservices';
import { MessageService } from './message.service';
import { createServiceLogger } from '@aether/shared';

const logger = createServiceLogger('message-controller');

@Controller()
export class MessageController {
  constructor(private readonly messageService: MessageService) {}

  @GrpcMethod('MessageService', 'SendMessage')
  async sendMessage(data: any) {
    try {
      logger.info('SendMessage gRPC call received', { 
        userId: data.userId, 
        roomId: data.roomId,
        messageType: data.messageType 
      });
      
      const result = await this.messageService.sendMessage(data);
      
      logger.info('SendMessage completed', { 
        success: result.success,
        messageId: result.messageData?.id 
      });
      
      return result;
    } catch (error) {
      logger.error('SendMessage failed:', error);
      return {
        success: false,
        message: 'Failed to send message',
        error: error.message,
      };
    }
  }

  @GrpcMethod('MessageService', 'GetMessageHistory')
  async getMessageHistory(data: any) {
    try {
      logger.info('GetMessageHistory gRPC call received', { 
        userId: data.userId, 
        roomId: data.roomId,
        page: data.page,
        limit: data.limit 
      });
      
      const result = await this.messageService.getMessageHistory(data);
      
      logger.info('GetMessageHistory completed', { 
        success: result.success,
        messageCount: result.messages?.length 
      });
      
      return result;
    } catch (error) {
      logger.error('GetMessageHistory failed:', error);
      return {
        success: false,
        message: 'Failed to get message history',
        error: error.message,
      };
    }
  }

  @GrpcMethod('MessageService', 'CreateRoom')
  async createRoom(data: any) {
    try {
      logger.info('CreateRoom gRPC call received', { 
        name: data.name, 
        createdBy: data.createdBy,
        roomType: data.roomType 
      });
      
      const result = await this.messageService.createRoom(data);
      
      logger.info('CreateRoom completed', { 
        success: result.success,
        roomId: result.room?.id 
      });
      
      return result;
    } catch (error) {
      logger.error('CreateRoom failed:', error);
      return {
        success: false,
        message: 'Failed to create room',
        error: error.message,
      };
    }
  }

  @GrpcMethod('MessageService', 'GetRooms')
  async getRooms(data: any) {
    try {
      logger.info('GetRooms gRPC call received', { userId: data.userId });
      
      const result = await this.messageService.getRooms(data);
      
      logger.info('GetRooms completed', { 
        success: result.success,
        roomCount: result.rooms?.length 
      });
      
      return result;
    } catch (error) {
      logger.error('GetRooms failed:', error);
      return {
        success: false,
        message: 'Failed to get rooms',
        error: error.message,
      };
    }
  }

  @GrpcMethod('MessageService', 'JoinRoom')
  async joinRoom(data: any) {
    try {
      logger.info('JoinRoom gRPC call received', { 
        userId: data.userId, 
        roomId: data.roomId 
      });
      
      const result = await this.messageService.joinRoom(data);
      
      logger.info('JoinRoom completed', { 
        success: result.success,
        roomId: data.roomId 
      });
      
      return result;
    } catch (error) {
      logger.error('JoinRoom failed:', error);
      return {
        success: false,
        message: 'Failed to join room',
        error: error.message,
      };
    }
  }

  @GrpcMethod('MessageService', 'HealthCheck')
  async healthCheck() {
    return {
      success: true,
      message: 'Message Service is healthy',
      service: 'message-service',
      version: '1.0.0',
      timestamp: new Date().toISOString(),
    };
  }
}
```

## Step 9: Module Configurations

### **services/message-service/src/message/message.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MessageController } from './message.controller';
import { MessageService } from './message.service';
import { Message, MessageSchema } from './schemas/message.schema';
import { Room, RoomSchema } from './schemas/room.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Message.name, schema: MessageSchema },
      { name: Room.name, schema: RoomSchema },
    ]),
  ],
  controllers: [MessageController],
  providers: [MessageService],
  exports: [MessageService],
})
export class MessageModule {}
```

### **services/message-service/src/socket/socket.module.ts**
```typescript
import { Module } from '@nestjs/common';
import { SocketGateway } from './socket.gateway';
import { MessageModule } from '../message/message.module';

@Module({
  imports: [MessageModule],
  providers: [SocketGateway],
})
export class SocketModule {}
```

## Step 10: Update Environment & Root Configuration

### **Update .env file**
```env
# Node Environment
NODE_ENV=development
LOG_LEVEL=debug

# Database URLs
POSTGRES_URL=postgresql://aether:secret123@localhost:5432/aetherconnect
MONGODB_URL=mongodb://aether:secret123@localhost:27017/aetherconnect
REDIS_URL=redis://:secret123@localhost:6379

# JWT Configuration
JWT_SECRET=your-super-secret-access-key-change-in-production-2025
JWT_REFRESH_SECRET=your-super-secret-refresh-key-change-in-production-2025

# Service Ports
API_GATEWAY_PORT=3000
AUTH_SERVICE_GRPC_PORT=50001
MESSAGE_SERVICE_GRPC_PORT=50002
MESSAGE_SERVICE_HTTP_PORT=3002

# Service URLs
AUTH_SERVICE_GRPC_URL=localhost:50001
MESSAGE_SERVICE_GRPC_URL=localhost:50002

# Frontend
FRONTEND_URL=http://localhost:3004
```

### **Update Root package.json scripts**
```json
{
  "name": "aetherconnect",
  "version": "1.0.0",
  "private": true,
  "workspaces": ["services/*", "packages/*"],
  "scripts": {
    "dev": "concurrently \"pnpm dev:auth\" \"pnpm dev:gateway\" \"pnpm dev:message\"",
    "dev:auth": "cd services/auth-service-nestjs && pnpm exec nest start --watch",
    "dev:gateway": "cd services/api-gateway && pnpm exec nest start --watch", 
    "dev:message": "cd services/message-service && pnpm exec nest start --watch",
    "build": "pnpm -r run build",
    "docker:up": "docker compose up -d",
    "setup": "pnpm install && pnpm docker:up && sleep 5"
  },
  "devDependencies": {
    "concurrently": "^8.2.2"
  }
}
```

## Step 11: Testing Commands

```bash
# 1. Install dependencies for message service
cd services/message-service
pnpm install
cd ../..

# 2. Update shared package and rebuild
cd packages/shared
pnpm build
cd ../..

# 3. Start infrastructure
pnpm docker:up

# 4. Start all services
pnpm dev

# You should see:
# üîê Auth Service (gRPC) is listening on port 50001
# üöÄ API Gateway is running on http://localhost:3000  
# üí¨ Message Service (gRPC) is listening on port 50002
# üåê Message Service (Socket.io) is listening on port 3002
```

## Step 12: Test Real-Time Messaging

### **Simple HTML Test Client** (create `test-client.html`)
```html
<!DOCTYPE html>
<html>
<head>
    <title>AetherConnect Test Client</title>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
</head>
<body>
    <h1>AetherConnect Chat Test</h1>
    
    <div>
        <input id="token" placeholder="JWT Token" style="width: 400px;"/>
        <button onclick="connect()">Connect</button>
    </div>
    
    <div>
        <input id="roomId" placeholder="Room ID (e.g., general)" value="general"/>
        <button onclick="joinRoom()">Join Room</button>
    </div>
    
    <div>
        <input id="message" placeholder="Type a message"/>
        <button onclick="sendMessage()">Send</button>
    </div>
    
    <div>
        <h3>Messages:</h3>
        <div id="messages" style="border: 1px solid #ccc; height: 300px; overflow-y: scroll; padding: 10px;"></div>
    </div>

    <script>
        let socket = null;
        
        function connect() {
            const token = document.getElementById('token').value;
            if (!token) {
                alert('Please enter a JWT token');
                return;
            }
            
            socket = io('http://localhost:3002', {
                auth: {
                    token: token
                }
            });
            
            socket.on('connected', (data) => {
                addMessage('‚úÖ Connected: ' + data.message);
            });
            
            socket.on('new_message', (data) => {
                addMessage(`${data.username}: ${data.content}`);
            });
            
            socket.on('user_joined', (data) => {
                addMessage(`üëã ${data.username} joined the room`);
            });
            
            socket.on('user_left', (data) => {
                addMessage(`üëã ${data.username} left the room`);
            });
            
            socket.on('error', (data) => {
                addMessage('‚ùå Error: ' + data.message);
            });
        }
        
        function joinRoom() {
            const roomId = document.getElementById('roomId').value;
            if (socket && roomId) {
                socket.emit('join_room', { roomId });
            }
        }
        
        function sendMessage() {
            const message = document.getElementById('message').value;
            const roomId = document.getElementById('roomId').value;
            
            if (socket && message && roomId) {
                socket.emit('send_message', { 
                    roomId, 
                    content: message,
                    messageType: 'text'
                });
                document.getElementById('message').value = '';
            }
        }
        
        function addMessage(text) {
            const messages = document.getElementById('messages');
            const div = document.createElement('div');
            div.textContent = new Date().toLocaleTimeString() + ' - ' + text;
            messages.appendChild(div);
            messages.scrollTop = messages.scrollHeight;
        }
    </script>
</body>
</html>
```

## Phase 4 Success Criteria

By the end of Day 12, you should have:

‚úÖ **Message Service** running on gRPC (port 50002) + Socket.io (port 3002)  
‚úÖ **MongoDB integration** for message and room persistence  
‚úÖ **Redis adapter** for Socket.io horizontal scaling  
‚úÖ **Real-time messaging** working via WebSocket  
‚úÖ **Room management** (create, join, leave rooms)  
‚úÖ **Message history** with pagination via gRPC  
‚úÖ **User authentication** integrated with Auth Service  
‚úÖ **Typing indicators** and user presence  
‚úÖ **Error handling** and comprehensive logging  

## What You Now Have

- **Complete real-time chat system** with WebSocket communication
- **Message persistence** in MongoDB with room management
- **Scalable architecture** with Redis for horizontal scaling
- **Type-safe gRPC communication** between all services
- **JWT authentication** integrated across the entire system
- **Production-ready logging** and error handling

**Your chat application is now LIVE with real-time messaging!** üéâ

Ready for **Phase 5: Frontend Integration**? Your custom frontend will connect to these powerful backend services! üöÄ